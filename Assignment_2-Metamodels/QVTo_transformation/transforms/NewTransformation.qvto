modeltype CCL uses "http://glt.tue.nl/ccl";
modeltype Graph uses "http://glt.tue.nl/graph";

transformation NewTransformation(in imodel : CCL, out omodel : Graph);

main() {
	imodel.rootObjects()[CloudResources]->map toModel();
}

mapping CCL::CloudResources::toModel(): Graph::Graph {
	self.resources.machineImages->map toNode();
	var res = self.resources->map toNode();
	res->forEach(n) {
		nodes += n.allNodes();
	};
	name := "Generated graph";
}

// Recursively creates a set of all nodes that are children of the node and the node itself.
query Graph::Node::allNodes(): Set(Graph::Node) {
	var nodes: Set(Graph::Node);
	nodes += self;
	self.outEdges->forEach(e) {
		nodes += e.target.allNodes();
	};
	return nodes;
}

mapping CCL::Resource::toNode(): Graph::Node {
	outEdges := self.machineImages[MachineImage]->map toEdge();
	label := self.label;
}

mapping CCL::MachineImage::toNode(): Graph::Node {
	label := self.label;
	var children: Set(Graph::Node);
	
	// Storage node:
	children += object Graph::Node {
		label := (self.storageSize.toString() + " GB");
		shape := Graph::Shape::OVAL;
	};
	
	// Storage/Computing dependent nodes:
	if self.oclIsTypeOf(CCL::ComputingImage) then {
		var os := self.oclAsType(CCL::ComputingImage).os.toString();
		children += object Graph::Node {
			label := os;
			shape := Graph::Shape::OVAL;
		};
		children += object Graph::Node {
			label := self.vcpu.toString();
			shape := Graph::Shape::OVAL;
		};
	} else { // It is a CCL::StorageImage
		var engine := self.oclAsType(CCL::StorageImage).dbEngine.toString();
		children += object Graph::Node {
			label := engine;
			shape := Graph::Shape::OVAL;
		};
	} endif;
	
	// Create edges for the new nodes:
	children->forEach(child) {
		outEdges += object Graph::Edge {
			style := Graph::Style::DOTTED;
			target := child
		};
	};
}

mapping CCL::MachineImage::toEdge(): Graph::Edge {
	target := self.resolveone(Graph::Node);
}
